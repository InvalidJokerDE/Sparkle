package de.fruxz.sparkle.framework.infrastructure.command.structured

import de.fruxz.sparkle.framework.extension.interchange.InterchangeExecutor
import de.fruxz.sparkle.framework.infrastructure.command.Interchange
import de.fruxz.sparkle.framework.infrastructure.command.InterchangeResult
import de.fruxz.sparkle.framework.infrastructure.command.InterchangeUserRestriction
import de.fruxz.sparkle.framework.infrastructure.command.InterchangeUserRestriction.NOT_RESTRICTED
import de.fruxz.sparkle.framework.infrastructure.command.completion.InterchangeStructure
import de.fruxz.sparkle.framework.infrastructure.command.live.InterchangeAccess
import de.fruxz.sparkle.framework.permission.Approval
import net.kyori.adventure.text.Component
import kotlin.coroutines.CoroutineContext
import kotlin.time.Duration

abstract class StructuredInterchange(
	label: String,
	val structure: InterchangeStructure<InterchangeExecutor>,
	aliases: Set<String> = emptySet(),
	protectedAccess: Boolean = true,
	userRestriction: InterchangeUserRestriction = NOT_RESTRICTED,
	ignoreInputValidation: Boolean = false,
	description: String = "An command, generated by sparkle!",
	permissionMessage: Component? = null,
	cooldown: Duration = Duration.ZERO,
	forcedApproval: Approval? = null,
	forcedExecutionContext: CoroutineContext? = null,
) : Interchange(
	label = label,
	aliases = aliases,
	requiresApproval = protectedAccess,
	requiredClient = userRestriction,
	completion = structure,
	ignoreInputValidation = ignoreInputValidation,
	description = description,
	permissionMessage = permissionMessage,
	cooldown = cooldown,
	forcedApproval = forcedApproval,
	forcedExecutionContext = forcedExecutionContext,
) {

	final override val execution: suspend InterchangeAccess<out InterchangeExecutor>.() -> InterchangeResult = {
		structure.performExecution(this)
	}

}